(set-logic QF_NRA_ODE)
(declare-fun v () Real [-1e+07, 1e+07])
(declare-fun z () Real [-1e+07, 1e+07])
(declare-fun u () Real [-1e+08, 1e+08])
(declare-fun lt () Real [0.000000, 0.01])
(declare-fun gt () Real [0.000000, 100])
(declare-fun state_v_0 () Real [-1e+07, 1e+07] )
(declare-fun state_z_0 () Real [-1e+07, 1e+07] )
(declare-fun next_u_0 () Real [-1e+08, 1e+08] )
(declare-fun v_0_0 () Real [-1e+07, 1e+07])
(declare-fun v_0_t () Real [-1e+07, 1e+07])
(declare-fun z_0_0 () Real [-1e+07, 1e+07])
(declare-fun z_0_t () Real [-1e+07, 1e+07])
(declare-fun u_0_0 () Real [-1e+08, 1e+08])
(declare-fun u_0_t () Real [-1e+08, 1e+08])
(declare-fun lt_0_0 () Real [0.000000, 0.01])
(declare-fun lt_0_t () Real [0.000000, 0.01])
(declare-fun gt_0_0 () Real [0.000000, 100])
(declare-fun gt_0_t () Real [0.000000, 100])
(declare-fun time_0 () Real [0.000000, 0])
(declare-fun mode_0 () Real [1.000000, 1.000000])
(declare-fun Noise__-1 () Real [0, 0])
(declare-fun state_v_1 () Real [-1e+07, 1e+07] )
(declare-fun state_z_1 () Real [-1e+07, 1e+07] )
(declare-fun next_u_1 () Real [-1e+08, 1e+08] )
(declare-fun v_1_0 () Real [-1e+07, 1e+07])
(declare-fun v_1_t () Real [-1e+07, 1e+07])
(declare-fun z_1_0 () Real [-1e+07, 1e+07])
(declare-fun z_1_t () Real [-1e+07, 1e+07])
(declare-fun u_1_0 () Real [-1e+08, 1e+08])
(declare-fun u_1_t () Real [-1e+08, 1e+08])
(declare-fun lt_1_0 () Real [0.000000, 0.01])
(declare-fun lt_1_t () Real [0.000000, 0.01])
(declare-fun gt_1_0 () Real [0.000000, 100])
(declare-fun gt_1_t () Real [0.000000, 100])
(declare-fun time_1 () Real [0.000000, 0.01])
(declare-fun mode_1 () Real [1.000000, 1.000000])
(define-ode flow_1 ((= d/dt[gt] 1) (= d/dt[lt] 1) (= d/dt[v] (+(*(/(- 50) 1000) v)(*(/ 1 1000) u))) (= d/dt[z] (- v 10)) (= d/dt[u] 0)))
(assert (and (= lt_0_0 0) (= gt_0_0 0) (<= u_0_0 500 )(>= u_0_0 450 )(>= z_0_0 40 )(<= z_0_0 70 )(>= v_0_0 50 )(<= v_0_0 80 )(= mode_0 1)  
 (= lt_0_t (+ lt_0_0 (* 1 0))) (= gt_0_t (+ gt_0_0 (* 1 0))) (= u_0_t (+ u_0_0 (* 0 0))) 
 (= [gt_0_t lt_0_t v_0_t z_0_t u_0_t ] (integral 0. time_0 [gt_0_0 lt_0_0 v_0_0 z_0_0 u_0_0 ] flow_1))  
 (= mode_1 1) (= lt_0_t 0) (= gt_1_0 gt_0_t) (= lt_1_0 0)  
 (= v_1_0 v_0_t)(= z_1_0 z_0_t)(= state_v_0 v_0_t ) (= state_z_0 z_0_t )  
 (= next_u_1 (- 10 (+ (* (- 10 state_v_0 ) 84101 ) (* state_z_0 40 ) ) ) ) 
  
 (= next_u_1 u_1_0 )  
 (= lt_1_t (+ lt_1_0 (* 1 time_1 ))) (= gt_1_t (+ gt_1_0 (* 1 time_1 ))) (= u_1_t (+ u_1_0 (* 0 time_1 ))) 
 (= [gt_1_t lt_1_t v_1_t z_1_t u_1_t ] (integral 0. time_1 [gt_1_0 lt_1_0 v_1_0 z_1_0 u_1_0 ] flow_1))  
 (forall_t 1 [0 time_1] (<= lt_1_t 0.01))   
 (<= lt_1_t 0.01) (<= lt_1_0 0.01) (= mode_1 1)  
 (>= gt_1_t 0.4  )(> v_1_t 11  ) ))
 (check-sat)
(exit)